import pandas as pd
import numpy as np
from scipy.stats import chi2


def get_data(input_file):
    '''
    Read data from a csv file. For the meaning of each variable,
    please see Ben-Tal et al. (2013)
    '''
    df = pd.read_csv(input_file)
    c_vec = np.array(df["c"])
    v_vec = np.array(df["v"])
    s_vec = np.array(df["s"])
    l_vec = np.array(df["l"])
    Q1_vec = np.array(df["q1"])
    Q2_vec = np.array(df["q2"])
    Q3_vec = np.array(df["q3"])
    # Q_mat is a J by I matrix (row: item, col: scenario)
    Q_mat = np.concatenate(([Q1_vec], [Q2_vec], [Q3_vec]), axis=0).T

    return c_vec, v_vec, s_vec, l_vec, Q_mat


def sample_p(Q_mat, num_sample, rho, m):
    '''
    Sample p-vectors for evaluation. The sampling process
    follows section 6.4 in Ben-Tal et al. (2013).
    Return:
    a J by num_sample by I numpy array.
    '''
    p_vector = []
    for j in range(Q_mat.shape[0]):
        p_j = []
        k = 0
        while k < num_sample:
            sample = []
            for i in range(m - 1):
                sigma = 0.5 * np.sqrt(rho / m * Q_mat[j, i])
                tmp = np.random.normal(loc=Q_mat[j, i], scale=sigma)
                sample.append(tmp)
            if min(sample) >= 0 and sum(sample) <= 1:  # ["min(sample) >= 0 and "]
                sample.append(1 - sum(sample))
                k += 1
                p_j.append(sample)
        p_vector.append(p_j)

    return np.array(p_vector)


def sample_p_dist(N, Q_mat, num_sample):
    '''
    Sample p-vectors for evaluation. Each p-vector is generated
    by a categorical distribution based on Q_mat.
    Return:
    a J by num_sample by I numpy array.
    '''
    I = Q_mat.shape[1]
    J = Q_mat.shape[0]
    p_vector = []
    for j in range(J):
        p_j = []
        for k in range(num_sample):
            unif = np.random.uniform(0, 1, N)
            prob = 0
            tmp = 0
            sample = []
            for i in range(I):
                prob += Q_mat[j, i]
                sample.append((len(unif[unif < prob]) - tmp) / N)
                tmp = len(unif[unif < prob])
            p_j.append(sample)
        p_vector.append(p_j)

    return np.array(p_vector)


def compute_rho(f_div_type, N, dof, alpha, Q=None, corrected=False):
    '''
    Compute the parameter rho. If corrected is true, the rho is defined
    by Pardo (2006, p. 190). Otherwise, it is defined by eq (7) in
    Ben-Tal et al. (2013).
    '''
    chi2_percentile = chi2.ppf(1 - alpha, dof)
    rho = []
    diff = {
        "Chi2": [2, -6, 24],
        "ModifiedChi2": [2, 0, 0],
        "Hellinger": [0.5, -0.75, 1.875]
    }
    if corrected:

        for j in range(Q.shape[0]):
            S = sum(1 / q for q in Q[j, :])
            M = dof + 1
            delta = 1 + 1 / (2 * (M - 1) * N) * (
                (2 - 2 * M - M ** 2 + S) +
                2 * diff[f_div_type][1] / diff[f_div_type][0] * (4 - 6 * M - M ** 2 + 3 * S) +
                1/3 * np.square(diff[f_div_type][1] / diff[f_div_type][0]) * (4 - 6 * M - 3 * M ** 2 + 5 * S) +
                2 * diff[f_div_type][2] / diff[f_div_type][0] * (1 - 2 * M + S)
            )
            gamma = (
                (M - 1) * (1 - np.sqrt(delta)) +
                1/N * (diff[f_div_type][1] / (3 * diff[f_div_type][0]) * (2 - 3 * M + S) +
                diff[f_div_type][2] / (4 * diff[f_div_type][0]) * (1 - 2 * M + S))
            )
            rho.append(diff[f_div_type][0] * (gamma + np.sqrt(delta) * chi2_percentile) / (2 * N))

    else:
        rho.append(diff[f_div_type][0] * chi2_percentile / (2 * N))
        rho = np.array(rho * Q.shape[0])
    return rho


def generate_newQ(Q_mat, N):
    '''
    Obtain a new Q matrix by computing the empirical distribution
    generated by the categorcal distribution based on the old Q_mat.
    '''
    I = Q_mat.shape[1]
    J = Q_mat.shape[0]
    Q_new = []
    for j in range(J):
        q_j = []
        unif = np.random.uniform(0, 1, N)
        prob = 0
        tmp = 0
        for i in range(I):
            prob += Q_mat[j, i]
            # to prevent computational issue when calculating the
            # corrected rho, if the probability for some component
            # is zero, change it to 0.001, which will not affect the
            # whole distribution a lot
            if (len(unif[unif < prob]) - tmp) / N != 0:
                q_j.append((len(unif[unif < prob]) - tmp) / N)
            else:
                q_j.append(0.001)
            tmp = len(unif[unif < prob])
        Q_new.append(q_j)

    return np.array(Q_new)
